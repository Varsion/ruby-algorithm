# Graph - 图

## 一些概念

- 图中的元素我们成为顶点(vertex),
- 图中的顶点可以与任意其他顶点建立联系,这种联系叫做边(edge)
- 顶点相连接的边的条数,称为顶点的度(degree)


### 有向图

有向图即顶点的边拥有方向,有向图中将顶点的度分为了:入度(In-degree)和出度(Out-degree)

顶点的入度,表示有多少条边指向这个顶点;顶点的出度,表示有多少条边是以这个顶点为起点指向其他顶点

### 带权图(weighted graph)

在带权图中，每条边都有一个权重(weight)


## 存储方式

### 邻接矩阵(Adjacency Matrix)

> 图最直观的一种存储方式就是**邻接矩阵**

邻接矩阵的底层依赖一个二维数组


对于无向图来说，如果顶点 i 与顶点 j 之间有边,我们就将 A[i][j]和 A[j][i]都标记为 1

对于有向图来说,如果顶点 i 到顶点 j 之间,有一条箭头从顶点 i 指向顶点 j 的边,那我们就将 A[i][j]标记为 1。同理,如果有一条箭头从顶点 j 指向顶点 i 的边,我们就将 A[j][i]标记为 1。

对于带权图,数组中就存储相应的权重。


用邻接矩阵来表示一个图，虽然简单、直观，但是比较浪费存储空间


对于无向图来说,如果 A[i][j]等于 1,那 A[j][i]也肯定等于 1。实际上,只需要存储一个就可以了。

也就是说,无向图的二维数组中,如果将其用对角线划分为上下两部分,那只需要利用上面或者下面这样一半的空间就足够了,另外一半白白浪费掉了。


当然这并不是说邻接矩阵一点优点都没有


首先，邻接矩阵的存储方式简单、直接,因为基于数组,所以在获取两个顶点的关系时,就非常高效。

其次,用邻接矩阵存储图的另外一个好处是方便计算。这是因为,用邻接矩阵的方式存储图,可以将很多图的运算转换成矩阵之间的运算。

### 邻接表(Adjacency List)

每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。

>邻接矩阵存储起来比较浪费空间，但是使用起来比较节省时间。相反，邻接表存储起来比较节省空间，但是使用起来就比较耗时间。



## About

邻接矩阵存储方法的缺点是比较浪费空间,但是优点是查询效率高,而且方便矩阵运算。

邻接表存储方法中每个顶点都对应一个链表,存储与其相连接的其他顶点。尽管邻接表的存储方式比较节省存储空间,但链表不方便查找,所以查询效率没有邻接矩阵存储方式高。

针对这个问题,邻接表还有改进升级版,即将链表换成更加高效的动态数据结构,比如平衡二叉查找树、跳表、散列表等。



## 搜索算法

广度优先搜索,通俗的理解就是,地毯式层层推进,从起始顶点开始,依次往外遍历。

广度优先搜索需要借助队列来实现,遍历得到的路径就是,起始顶点到终止顶点的最短路径。

深度优先搜索用的是回溯思想,非常适合用递归实现。换种说法,深度优先搜索是借助栈来实现的。

在执行效率方面,深度优先和广度优先搜索的时间复杂度都是 O(E),空间复杂度是 O(V)。

### BFS

广度优先搜索(Breadth-First-Search)

直观地讲,它其实就是一种“地毯式”层层推进的搜索策略,即先查找离起始顶点最近的,然后是次近的,依次往外搜索。

最坏情况下,终止顶点 t 离起始顶点 s 很远,需要遍历完整个图才能找到。

这个时候,每个顶点都要进出一遍队列,每个边也都会被访问一次,

所以,广度优先搜索的时间复杂度是 O(V+E),其中,V 表示顶点的个数,E 表示边的个数。

当然,对于一个连通图来说,也就是说一个图中的所有顶点都是连通的,E 肯定要大于等于 V-1,所以,广度优先搜索的时间复杂度也可以简写为 O(E)。


### DFS

深度优先搜索(Depth-First-Search) 最直观的例子就是“走迷宫”。

假设你站在迷宫的某个岔路口，然后想找到出口。你随意选择一个岔路口来走，走着走着发现走不通的时候，你就回退到上一个岔路口，重新选择一条路继续走，直到最终找到出口。

这种走法就是一种深度优先搜索策略。

实际上，深度优先搜索用的是一种比较著名的算法思想，回溯思想。这种思想解决问题的过程，非常适合用递归来实现。